from guardian import GuardState
from guardian import GuardStateDecorator
from guardian import NodeManager
import vislib
from slack_util import PostMan
##################################################
# initialization values

# initial REQUEST state
request = 'INIT'

# NOMINAL state, which determines when node is OK
nominal = 'VISMON'

##################################################

# Necessary??
#nodes = NodeManager(['VIS_PR2', 'VIS_PR3', 'VIS_PRM', 'VIS_BS', 'VIS_SR2', 'VIS_SR3', 'VIS_SRM', 'VIS_ETMX', 'VIS_ITMX', 'VIS_ETMY', 'VIS_ITMY', ])

optics = ['PR2', 'PR3', 'SR2', 'SR3', 'BS', 'ETMX', 'ITMX', 'ETMY', 'ITMY']

# ------------------------------------------------------------------------------
def send_to_slack(text):
    ''' Need token. Plase
    '''
    postman = PostMan(token='')
    postman.chat_post(text)
    return True    
    
# ------------------------------------------------------------------------------

WAIT_TIME_FOR_DAMPING = 600
WAIT_TIME_FOR_ALIGNING = 10
OL_SUM_MIN = 100
OL_RMS_MAX = 100
NOTIFICATION = True

def pay_localdamped(opt):
    return ezca['GRD-VIS_'+opt+'_STATE']=='PAY_LOCALDAMPED'

def oldamped(opt):
    return ezca['GRD-VIS_'+opt+'_STATE']=='OLDAMPED'

def damped(opt):
    return pay_localdamped(opt) or lodamped(opt)

def aligned(opt):
    return ezca['GRD-VIS_'+opt+'_STATE']=='ALIGNED'

def request_pay_loacldamp(opt):
    return ezca['GRD-VIS_'+opt+'_REQUEST']=='PAY_LOCALDAMPED'

def request_oldamp(opt):
    return ezca['GRD-VIS_'+opt+'_REQUEST']=='OLDAMPED'    

def request_damp(opt):
    return request_pay_localdamp(opt) or request_lodamp(opt)
    
def bad_olctrl(opt):
    '''
    '''
    ol_sum = ezca['VIS-{0}_TM_OPLEV_TILT_SUM_OUT16'.format(opt)]
    return ol_sum<=OL_SUM_MIN and aligned(opt)

def big_rms(opt):
    '''
    '''
    if opt in ['ETMX', 'ITMX', 'ETMY', 'ITMY']
        ol_pit_rms = ezca['VIS-{0}_TM_OL_WD_TILT_V_RMSMON'.format(opt)]
        ol_yaw_rms = ezca['VIS-{0}_TM_OL_WD_TILT_H_RMSMON'.format(opt)]
    else:
        ol_pit_rms = ezca['VIS-{0}_TM_OPLEV_BLRMS_P_30M_100M'.format(opt)]
        ol_yaw_rms = ezca['VIS-{0}_TM_OPLEV_BLRMS_Y_30M_100M'.format(opt)]
        
    return (ol_pit_rms>=OL_RMS_MAX or ol_yaw_rms>=OL_RMS_MAX) and aligned(opt)


# ------------------------------------------------------------------------------
class INIT(GuardState):
    ''' Initial State of VIS_MANAGER.

    '''
    index = 0
    goto = True
    
    def main(self):
        '''
        '''
        #for opt in optics:
            #nodes.set_managed()
        return True

    
class ALL_ALIGNED(GuardState):
    ''' The state to aligne the all suspensions
    
    '''    
    index = 1
    request = True
    
    def main(self):
        ''' All suspensions are requested to ALIGNED.
        '''        
        for opt in optics:
            ezca['GRD-VIS_'+opt+'_REQUEST'] = 'ALIGNED'
        return True


class VISMON(GuardState):
    ''' The state to monitor the OpLev 

    各サスペンションの状況に応じてリクエストを出し、その様子をSlack（仮）で
    通知するためのステイト(今はOplevだけを見てリクエストを出している)
        
    '''
    index = 10
    request = True

    def main(self):
        ''' Initilize the flags
                
        フラグなどを初期化する。

        '''
        BACK_TO_ALIGNED = False
        ALREADY_SENT = True
        for opt in optics:
            self.timer[opt+'_DAMPING'] = 0           
            self.timer[opt+'_ALIGNING'] = 0
            wait_damping[opt] = False
            wait_aligning[opt] = False
        return False
    
    def run(self):
        ''' Run 

        OpLevの状態に応じてリクエストを出す。
            1) Oplevが異常なら,PAY_LOCALDAMPEDをリクエスト
            2) Oplevが正常でもRMSが大きいなら,OLDAMPEDをリクエスト
            3) Oplevが正常でRMSも小さいなら,ALIGNEDをリクエスト
    
        リクエストを出したあとの状態に応じて通知をだす。
            a) 無事に PAY_LOCALDAMPED か OLDAMPED に移ったとき
            b) いずれの DAMP 状態にも戻れないとき
            c) 無事に ALIGNED へ復帰できたとき

        '''
        for opt in optics:
            # (1)
            if bad_olctrl(opt): 
                ezca['GRD-VIS_'+opt+'_REQUEST'] = 'PAY_LOCALDAMPED'
                wait_damping[opt] = not self.timer[opt+'_DAMPING']
                if not wait_damping[opt] and not pay_localdamped(opt):
                    self.timer[opt+'_DAMPING'] = WAIT_TIME_FOR_DAMPING
                    wait_aligning[opt] = False

            # (2)                    
            elif not bad_olctrl(opt) and big_rms(opt): 
                ezca['GRD-VIS_'+opt+'_REQUEST'] = 'OLDAMPED'
                wait_damping[opt] = not self.timer[opt+'_DAMPING']
                if not wait_damping[opt] and not oldamped(opt):
                    self.timer[opt+'_DAMPING'] = WAIT_TIME_FOR_DAMPING 
                    wait_aligning[opt] = False
                    
            # (3)                    
            else: 
                ezca['GRD-VIS_'+opt+'_REQUEST'] = 'ALIGNED'
                wait_aligning[opt] = not self.timer[opt+'_DAMPING']
                if not wait_aligning[opt] and not aligned(opt): 
                    self.timer[opt+'_ALIGNING'] = WAIT_TIME_FOR_ALIGNING
                    wait_damping[opt] = False
                    
            # (a) 
            if not wait_damping[opt] and request_damp(opt) and damped(opt): 
                if NOTIFICATION and not ALREADY_SENT:
                    current = ezca['GRD-VIS_'+opt+'_STATE']
                    text = \
                      '{0} is damped at {1} state. Please wait until ' + \
                      'the RMS value of the OpLev subsides.'.format(opt,current)
                    send_to_slack(text)
                    ALREADY_SENT = True
                    
            # (b) 
            if not wait_damping[opt] and request_damp(opt) and not damped(opt):
                if NOTIFICATION and not ALREADY_SENT:
                    text = \
                      'The oplev value of {0} have not settled. ' + \
                      'Please check manualy.'.format(opt,current)
                    send_to_slack(text)                    

            # (c) 
            if not wait_aligning[opt] and request_align(opt) and aligned(opt):
                if NOTIFICATION and BACK_TO_ALIGNED:
                    send_to_slack('{0} back to ALIGNED state.'.format(opt))
                    BACK_TO_ALIGNED = False
                    ALREADY_SENT = False               
        return False

# ------------------------------------------------------------------------------
edges = [
    ('INIT','ALL_ALIGNED'),
    ('INIT','VISMON'),
    ('ALL_ALIGNED','VISMON'),
    ('VISMON','ALL_ALIGNED')]
